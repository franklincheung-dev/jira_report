/**
 * Agile Project Insights Dashboard - Main JavaScript
 */

$(document).ready(function() {
    // Global variables
    let currentSprintIndex = -1;
    let currentDashboardData = null;
    
    // Load archived sprints when the page loads
    loadArchivedSprints();
    
    // Add team capacity calculation hint on page load
    addTeamCapacityHint();
    
    // Make sure Plotly is ready
    if (typeof Plotly === 'undefined') {
        console.error('Plotly.js is not loaded! Charts will not render correctly.');
    } else {
        console.log('Plotly.js is loaded and ready for chart rendering.');
    }
    
    /**
     * Handle file upload form submission
     */
    $('#upload-form').submit(function(e) {
        e.preventDefault();
        
        const formData = new FormData();
        const fileInput = $('#file-upload')[0];
        
        if (fileInput.files.length === 0) {
            alert('Please select a file to upload.');
            return;
        }
        
        formData.append('file', fileInput.files[0]);
        
        // Show loading indicator
        $('#loading').removeClass('d-none');
        
        // Upload file
        $.ajax({
            url: '/upload',
            type: 'POST',
            data: formData,
            processData: false,
            contentType: false,
            success: function(response) {
                $('#loading').addClass('d-none');
                
                if (response.status === 'success') {
                    // File uploaded successfully
                    populateSprintDropdown(response.sprints);
                    
                    // Enable controls
                    $('#sprint-select').prop('disabled', false);
                    $('#team-capacity').prop('disabled', false);
                    $('#generate-dashboard').prop('disabled', false);
                    $('#archive-current').prop('disabled', false);
                    
                    // Auto-fetch assignees and projects data too
                    currentSprintIndex = response.sprints.length > 0 ? 
                        response.sprints[response.sprints.length - 1].index : -1;
                    
                    // Fetch assignee and project data after upload, but check if API endpoints exist
                    try {
                        fetchAssigneeData(currentSprintIndex);
                        fetchProjectData(currentSprintIndex);
                    } catch(e) {
                        console.warn('Could not fetch assignee/project data:', e);
                        // Continue even if these fail, as they're enhancements
                    }
                } else {
                    // Error uploading file
                    alert('Error: ' + response.message);
                }
            },
            error: function() {
                $('#loading').addClass('d-none');
                alert('Error uploading file. Please try again.');
            }
        });
    });
    
    /**
     * Populate sprint dropdown with available sprints
     */
    function populateSprintDropdown(sprints) {
        const $select = $('#sprint-select');
        $select.empty();
        
        if (sprints && sprints.length > 0) {
            // Sort sprints intelligently - this should match backend sorting
            sprints.sort((a, b) => {
                // Helper function to extract sprint information
                function extractSprintInfo(sprintName) {
                    if (typeof sprintName !== 'string') {
                        return { type: 0, year: 0, number: 0, text: String(sprintName) };
                    }
                    
                    // Match pattern like "2025 Sprint 9"
                    const yearSprintMatch = sprintName.match(/(\d{4})\s+Sprint\s+(\d+)/);
                    if (yearSprintMatch) {
                        return { 
                            type: 1, 
                            year: parseInt(yearSprintMatch[1], 10), 
                            number: parseInt(yearSprintMatch[2], 10), 
                            text: sprintName 
                        };
                    }
                    
                    // Match pattern like "Sprint 9"
                    const sprintMatch = sprintName.match(/Sprint\s+(\d+)/);
                    if (sprintMatch) {
                        return { 
                            type: 2, 
                            year: 0, 
                            number: parseInt(sprintMatch[1], 10), 
                            text: sprintName 
                        };
                    }
                    
                    // Default: alphabetical sort
                    return { type: 3, year: 0, number: 0, text: sprintName };
                }
                
                const infoA = extractSprintInfo(a.name);
                const infoB = extractSprintInfo(b.name);
                
                // Sort by type first
                if (infoA.type !== infoB.type) {
                    return infoA.type - infoB.type;
                }
                
                // If same type, sort by year (for type 1)
                if (infoA.type === 1 && infoA.year !== infoB.year) {
                    return infoA.year - infoB.year;
                }
                
                // If same year or not year-based, sort by sprint number
                if ((infoA.type === 1 || infoA.type === 2) && infoA.number !== infoB.number) {
                    return infoA.number - infoB.number;
                }
                
                // Default to text comparison
                return infoA.text.localeCompare(infoB.text);
            });
            
            // Update indices after sorting
            sprints.forEach((sprint, i) => {
                sprint.sortedIndex = i;
            });
            
            sprints.forEach(function(sprint) {
                // Format the sprint text with additional info if available
                let sprintText = sprint.name;
                
                // Add details (total points, completion) if available
                if (sprint.total_points !== undefined && sprint.total_points > 0) {
                    const completionPercentage = sprint.total_points > 0 ? 
                        Math.round((sprint.completed_points / sprint.total_points) * 100) : 0;
                    sprintText += ` (${sprint.completed_points}/${sprint.total_points} hrs, ${completionPercentage}%)`;
                }
                
                $select.append(`<option value="${sprint.index}">${sprintText}</option>`);
            });
            
            // Select the most recent sprint by default
            $select.val(sprints[sprints.length - 1].index);
            currentSprintIndex = sprints[sprints.length - 1].index;
        } else {
            $select.append('<option value="">No sprints available</option>');
        }
    }
    
    // Fetch issue types and billable configuration functions removed as requested
    
    /**
     * Handle sprint selection change
     */
    $('#sprint-select').change(function() {
        currentSprintIndex = $(this).val();
        // No need to regenerate the dashboard here - the user will click the Generate Dashboard button
    });
    
    /**
     * Add a helpful capacity calculation hint
     */
    function addTeamCapacityHint() {
        // Get the capacity input group
        const $capacityGroup = $('#team-capacity').closest('.form-group');
        
        // Check if the hint already exists to avoid duplicates
        if ($capacityGroup.find('.capacity-hint').length === 0) {
            // Calculate a simple example (7 people × 8 hours × 5 days = 280 hours)
            $capacityGroup.append('<small class="text-muted d-block mt-1 capacity-hint"><i class="fas fa-calculator"></i> Example: 7 people × 8 hours × 5 days = 280 hours</small>');
        }
    }
    
    /**
     * Generate dashboard based on selected sprint
     */
    $('#generate-dashboard').click(function() {
        // Get selected sprint index
        const sprintIndex = $('#sprint-select').val();
        currentSprintIndex = sprintIndex;
        
        // Get team capacity
        const teamCapacity = parseFloat($('#team-capacity').val()) || 0;
        
        // Hide upload prompt
        $('#upload-prompt').addClass('d-none');
        
        // Show loading indicator
        $('#loading').removeClass('d-none');
        
        // Validate chart containers
        validateChartContainers();
        
        // Validate chart containers before making request
        validateChartContainers();
        
        // Generate dashboard
        $.ajax({
            url: '/get-dashboard',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                sprint_index: sprintIndex,
                team_capacity: teamCapacity
            }),
            success: function(response) {
                $('#loading').addClass('d-none');
                
                if (response.status === 'success') {
                    // Show dashboard container
                    $('#dashboard-container').removeClass('d-none');
                    
                    // Store dashboard data for later use
                    currentDashboardData = response.dashboard;
                    
                    // Log dashboard data to inspect structure
                    console.log('Dashboard data received:', response.dashboard);
                    
                    // Update dashboard with data
                    updateDashboard(response.dashboard);
                    
                    // Fetch assignee and project data
                    fetchAssigneeData(sprintIndex);
                    fetchProjectData(sprintIndex);
                } else {
                    // Error generating dashboard
                    console.error('Error generating dashboard:', response.message);
                    alert('Error: ' + response.message);
                }
            },
            error: function(xhr, status, error) {
                $('#loading').addClass('d-none');
                console.error('AJAX error:', status, error);
                alert('Error generating dashboard. Please try again.');
            }
        });
    });
    
    /**
     * Validate chart containers before rendering
     */
    function validateChartContainers() {
        const chartIds = [
            // Main dashboard charts
            'completion-chart', 'velocity-chart', 'billable-chart', 'capacity-chart',
            // Assignee detail charts
            'assignee-completion-chart', 'assignee-category-chart',
            // Project detail charts
            'project-completion-chart', 'project-resource-allocation-chart'
        ];
        
        chartIds.forEach(id => {
            const container = $(`#${id}`);
            if (container.length === 0) {
                console.error(`Chart container #${id} not found in HTML!`);
            } else {
                // Check if container has size
                const width = container.width();
                const height = container.height();
                
                if (width === 0 || height === 0) {
                    console.warn(`Chart container #${id} has zero width or height. Width: ${width}px, Height: ${height}px`);
                    // Try to ensure container has size
                    container.css({
                        'min-height': '250px',
                        'width': '100%',
                        'display': 'block',
                        'visibility': 'visible'
                    });
                } else {
                    console.log(`Chart container #${id} size: Width: ${width}px, Height: ${height}px`);
                }
            }
        });
    }
    
    /**
     * Fetch assignee data from the server
     */
    function fetchAssigneeData(sprintIndex) {
        console.log('Fetching assignee data for sprint index:', sprintIndex);
        
        $.ajax({
            url: '/get-assignee-data',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                sprint_index: sprintIndex
            }),
            success: function(response) {
                console.log('Received assignee data:', response);
                if (response.status === 'success') {
                    // Render assignee filter bubbles
                    renderAssigneeBubbles(response.assignees);
                } else {
                    console.error('Error in assignee data response:', response.message || 'Unknown error');
                }
            },
            error: function(xhr, status, error) {
                console.error('Error fetching assignee data:', status, error);
            }
        });
    }
    
    /**
     * Fetch project data from the server
     */
    function fetchProjectData(sprintIndex) {
        console.log('Fetching project data for sprint index:', sprintIndex);
        
        $.ajax({
            url: '/get-project-data',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                sprint_index: sprintIndex
            }),
            success: function(response) {
                console.log('Received project data:', response);
                if (response.status === 'success') {
                    // Render project filter bubbles
                    renderProjectBubbles(response.projects);
                } else {
                    console.error('Error in project data response:', response.message || 'Unknown error');
                }
            },
            error: function(xhr, status, error) {
                console.error('Error fetching project data:', status, error);
            }
        });
    }
    
    /**
     * Update dashboard with data received from server
     * @param {Object} dashboard - Dashboard data from server
     */
    function updateDashboard(dashboard) {
        console.log('Received dashboard data:', dashboard);
        
        if (!dashboard) {
            console.error('No dashboard data received');
            return;
        }
        
        // Store the current dashboard data for reference
        currentDashboardData = dashboard;
        
        const metrics = dashboard.metrics || {};
        if ($.isEmptyObject(metrics)) {
            console.warn('Dashboard metrics are empty');
        }
        
        // Log blockers for debugging
        console.log('Dashboard metrics object:', metrics);
        console.log('Blockers property existence:', 'blockers' in metrics);
        console.log('Blockers array?', Array.isArray(metrics.blockers));
        console.log('Blockers length:', metrics.blockers ? metrics.blockers.length : 'N/A');
        
        // Set the sprint name
        $('#sprint-name').text(metrics.sprint_name || 'Unknown Sprint');
        $('#sprint-status').text(metrics.sprint_status || 'Unknown');
        
        // Update sprint status indicator
        updateSprintStatusIndicator(metrics.sprint_status);
        
        // Parse charts
        updateCharts(dashboard);
        
        // Update blockers list if available
        // First check for blockers at the top level of the dashboard
        if (dashboard.blockers && Array.isArray(dashboard.blockers) && dashboard.blockers.length > 0) {
            console.log('Found blockers in dashboard data (top level):', dashboard.blockers);
            updateBlockersList(dashboard.blockers);
        }
        // Then check for blockers in the metrics property as a fallback
        else if (dashboard.metrics && dashboard.metrics.blockers && 
                Array.isArray(dashboard.metrics.blockers) && dashboard.metrics.blockers.length > 0) {
            console.log('Found blockers in dashboard metrics:', dashboard.metrics.blockers);
            updateBlockersList(dashboard.metrics.blockers);
        }
        else {
            console.warn('No blockers found in dashboard data');
            $('#blockers-list').html('<p class="text-muted">No blockers or at-risk items found for this sprint.</p>');
        }
    }
    
    /**
     * Update the blockers list with data from the server
     * @param {Array} blockers - List of blocker items
     */
    function updateBlockersList(blockers) {
        const container = $('#blockers-list');
        if (container.length === 0) {
            console.error('Blockers list container (#blockers-list) not found in HTML!');
            return;
        }
        
        console.log('Updating blockers list with data:', blockers);
        container.empty();
        
        // Enhanced validation to handle different data formats
        if (!blockers || !Array.isArray(blockers) || blockers.length === 0) {
            container.append('<p class="text-muted">No blockers or at-risk items found.</p>');
            return;
        }
        
        // Check if we need to parse the blockers (might be sent as a JSON string)
        let blockersData = blockers;
        if (typeof blockers === 'string') {
            try {
                blockersData = JSON.parse(blockers);
                console.log('Successfully parsed blockers JSON string:', blockersData);
            } catch (error) {
                console.error('Failed to parse blockers data:', error);
                container.append('<p class="text-muted">Error parsing blockers data. See console for details.</p>');
                return;
            }
        }
        
        // Create table with striped rows for better visibility
        const table = $(`
            <table class="table table-sm table-hover">
                <thead>
                    <tr>
                        <th>Issue</th>
                        <th>Summary</th>
                        <th>Assignee</th>
                        <th>Status</th>
                        <th>Due Date</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        `);
        
        const tbody = table.find('tbody');
        
        // Track counts of different blocker types
        let overdueCount = 0;
        let incompleteCount = 0;
        
        // Check for different property naming conventions
        blockersData.forEach(blocker => {
            // Extract blocker type from different possible properties
            const blockerType = blocker['blocker_type'] || blocker['blockerType'] || 'incomplete';
            
            // Create row with appropriate styling based on blocker type
            const rowClass = blockerType === 'overdue' ? 'table-danger' : 'table-warning';
            const row = $(`<tr class="${rowClass}"></tr>`);
            
            // Count by type
            if (blockerType === 'overdue') {
                overdueCount++;
            } else {
                incompleteCount++;
            }
            
            // Extract issue key from different possible properties
            const issueKey = blocker['Issue key'] || blocker['issue_key'] || blocker['issueKey'] || blocker['key'] || 'N/A';
            
            // Extract summary from different possible properties
            const summary = blocker['Summary'] || blocker['summary'] || 'N/A';
            
            // Extract assignee from different possible properties
            const assignee = blocker['Assignee'] || blocker['assignee'] || 'Unassigned';
            
            // Extract status from different possible properties
            const status = blocker['Status'] || blocker['status'] || 'Unknown';
            
            // Format due date - handle different date formats and properties
            let dueDate = 'Not set';
            const dueDateValue = blocker['Due date'] || blocker['due_date'] || blocker['dueDate'];
            if (dueDateValue) {
                try {
                    // Handle ISO string or date object
                    dueDate = new Date(dueDateValue).toLocaleDateString();
                } catch(e) {
                    console.warn('Could not format date:', dueDateValue, e);
                    dueDate = String(dueDateValue);
                }
            }
            
            // Add status class for styling
            const statusClass = getStatusClass(status);
            
            row.append(`<td><a href="#" class="issue-link">${issueKey}</a></td>`);
            row.append(`<td>${summary}</td>`);
            row.append(`<td>${assignee}</td>`);
            row.append(`<td><span class="status-pill ${statusClass}">${status}</span></td>`);
            row.append(`<td>${dueDate}</td>`);
            
            tbody.append(row);
        });
        
        container.append(table);
        
        // Add a summary of blockers above the table
        const totalBlockers = blockersData.length;
        const summaryHTML = $(`
            <div class="blockers-summary mb-3">
                <div class="d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">Summary</h6>
                    <span class="badge bg-danger">${totalBlockers} total items</span>
                </div>
                <div class="mt-2 d-flex gap-3">
                    <div class="blocker-type-count">
                        <span class="badge bg-danger">${overdueCount}</span> overdue/high priority
                    </div>
                    <div class="blocker-type-count">
                        <span class="badge bg-warning text-dark">${incompleteCount}</span> incomplete tasks
                    </div>
                </div>
            </div>
        `);
        container.prepend(summaryHTML);
    }
    
    /**
     * Update the capacity forecast section with projected capacity data
     * @param {Object} projectedCapacity - Projected capacity data
     */
    function updateCapacityForecast(projectedCapacity) {
        const container = $('#capacity-forecast');
        if (container.length === 0) {
            console.error('Capacity forecast container (#capacity-forecast) not found in HTML!');
            return;
        }
        
        console.log('Updating capacity forecast with data:', projectedCapacity);
        container.empty();
        
        if (!projectedCapacity) {
            container.append('<p class="text-muted">No forecast data available.</p>');
            return;
        }
        
        // Get data for the current, next sprint and sprint after next
        const currentSprint = projectedCapacity.current_sprint || {};
        const nextSprint = projectedCapacity.next_sprint || {};
        const nextNextSprint = projectedCapacity.next_next_sprint || {};
        const historical = projectedCapacity.historical || {};
        
        // Create a forecast panel for the cards
        const forecastPanel = $('<div class="row forecast-row"></div>');
        
        // Function to create a forecast card
        function createForecastCard(sprint, title, badgeText, badgeClass) {
            if (!sprint || sprint.forecast_hours === undefined) return null;
            
            // Format category breakdown
            let categoryHtml = '';
            if (sprint.category_breakdown) {
                categoryHtml = '<div class="category-breakdown mt-3">';
                categoryHtml += '<h6 class="text-muted mb-2">Category Breakdown</h6>';
                categoryHtml += '<div class="row">';
                
                for (const [category, hours] of Object.entries(sprint.category_breakdown)) {
                    const categoryClass = category.toLowerCase();
                    categoryHtml += `
                        <div class="col-6 mb-2">
                            <span class="badge category-${categoryClass}">${category}</span>
                            <span class="ms-2">${hours.toFixed(1)} hrs</span>
                        </div>
                    `;
                }
                
                categoryHtml += '</div></div>';
            }
            
            // Allocation metrics
            let allocationHtml = '';
            if (sprint.unallocated_hours !== undefined) {
                const allocatedPct = sprint.allocated_hours && sprint.forecast_hours ? 
                    Math.round((sprint.allocated_hours / sprint.forecast_hours) * 100) : 0;
                
                allocationHtml = `
                    <div class="allocation-metrics mt-3">
                        <div class="d-flex justify-content-between">
                            <span class="text-muted">Allocated</span>
                            <span>${sprint.allocated_hours ? sprint.allocated_hours.toFixed(1) : '0.0'} hrs (${allocatedPct}%)</span>
                        </div>
                        <div class="d-flex justify-content-between">
                            <span class="text-muted">Unallocated</span>
                            <span>${sprint.unallocated_hours.toFixed(1)} hrs (${sprint.remaining_percentage}%)</span>
                        </div>
                    </div>
                `;
            }
            
            return $(`
                <div class="col-md-4 mb-3">
                    <div class="card h-100">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h6 class="m-0">${title}</h6>
                            <span class="badge ${badgeClass}">${badgeText}</span>
                        </div>
                        <div class="card-body">
                            <div class="text-center mb-3">
                                <h3>${sprint.forecast_hours.toFixed(1)} hours</h3>
                                <p class="text-muted mb-0">${sprint.sprint_name}</p>
                            </div>
                            ${categoryHtml}
                            ${allocationHtml}
                        </div>
                    </div>
                </div>
            `);
        }
        
        // Add current sprint forecast
        const currentSprintCard = createForecastCard(
            currentSprint, 
            "Current Sprint", 
            "Current", 
            "bg-success"
        );
        if (currentSprintCard) {
            forecastPanel.append(currentSprintCard);
        }
        
        // Add next sprint forecast
        const nextSprintCard = createForecastCard(
            nextSprint, 
            "Next Sprint Forecast", 
            "Expected", 
            "bg-primary"
        );
        if (nextSprintCard) {
            forecastPanel.append(nextSprintCard);
        }
        
        // Add sprint after next forecast
        const nextNextSprintCard = createForecastCard(
            nextNextSprint, 
            "Sprint After Next", 
            "Projected", 
            "bg-info"
        );
        if (nextNextSprintCard) {
            forecastPanel.append(nextNextSprintCard);
        }
        
        container.append(forecastPanel);
        
        // Add historical metrics and context
        if (historical) {
            const historicalSection = $(`
                <div class="historical-metrics mt-4">
                    <h6><i class="fas fa-history"></i> Historical Context</h6>
                    <div class="row">
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-title">Average Velocity</div>
                                <div class="metric-value">${historical.avg_velocity ? historical.avg_velocity.toFixed(1) : '0.0'} hrs</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-title">Latest Moving Avg</div>
                                <div class="metric-value">${historical.latest_moving_avg ? historical.latest_moving_avg.toFixed(1) : '0.0'} hrs</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-title">Historical Utilization</div>
                                <div class="metric-value">${currentSprint && currentSprint.historical_utilization ? currentSprint.historical_utilization.toFixed(1) : '0.0'}%</div>
                            </div>
                        </div>
                    </div>
                </div>
            `);
            
            container.append(historicalSection);
        }
        
        // Add data quality notes if available
        if (historical && historical.data_quality_warning) {
            container.append(`<div class="forecast-notes mt-3"><p class="text-warning"><i class="fas fa-exclamation-triangle"></i> ${historical.data_quality_warning}</p></div>`);
        }
        
        // Add forecast notes if available
        if (projectedCapacity.notes) {
            container.append(`<div class="forecast-notes mt-3"><p class="text-muted"><i class="fas fa-info-circle"></i> ${projectedCapacity.notes}</p></div>`);
        }
    }
    
    /**
     * Render assignee filter bubbles
     */
    function renderAssigneeBubbles(assignees) {
        const container = $('#assignee-bubbles');
        container.empty();
        
        if (!assignees || assignees.length === 0) {
            container.append('<p class="text-muted">No assignee data available</p>');
            return;
        }
        
        // Sort assignees by workload (total points) in descending order
        assignees.sort((a, b) => b.total_points - a.total_points);
        
        // Create a bubble for each assignee
        assignees.forEach(assignee => {
            // Get workload class based on total points
            const workloadClass = getWorkloadClass(assignee.total_points);
            
            // Create initials for the avatar
            const initials = getInitials(assignee.name);
            
            const bubble = $(`
                <div class="filter-bubble assignee-bubble" data-assignee="${assignee.name}">
                    <div class="avatar">${initials}</div>
                    <span>${assignee.name}</span>
                    <span class="ms-2 workload-indicator ${workloadClass}"></span>
                </div>
            `);
            
            // Store assignee data in the bubble for later use
            bubble.data('assigneeData', assignee);
            
            // Add click event to show assignee details
            bubble.click(function() {
                // Remove active class from all assignee bubbles
                $('.assignee-bubble').removeClass('active');
                // Add active class to this bubble
                $(this).addClass('active');
                
                // Show assignee details
                showAssigneeDetails($(this).data('assigneeData'));
                
                // Hide project details if visible
                $('#project-detail-view').addClass('d-none');
                $('.project-bubble').removeClass('active');
            });
            
            container.append(bubble);
        });
    }
    
    /**
     * Render project filter bubbles
     */
    function renderProjectBubbles(projects) {
        const container = $('#project-bubbles');
        container.empty();
        
        if (!projects || projects.length === 0) {
            container.append('<p class="text-muted">No project data available</p>');
            return;
        }
        
        // Sort projects by total points in descending order
        projects.sort((a, b) => b.total_points - a.total_points);
        
        // Create a bubble for each project
        projects.forEach(project => {
            // Calculate completion class
            const completionClass = getCompletionClass(project.completion_percentage);
            
            const bubble = $(`
                <div class="filter-bubble project-bubble ${completionClass}" data-project="${project.name}">
                    <i class="fas fa-project-diagram me-2"></i>
                    <span>${project.name}</span>
                </div>
            `);
            
            // Store project data in the bubble for later use
            bubble.data('projectData', project);
            
            // Add click event to show project details
            bubble.click(function() {
                // Remove active class from all project bubbles
                $('.project-bubble').removeClass('active');
                // Add active class to this bubble
                $(this).addClass('active');
                
                // Show project details
                showProjectDetails($(this).data('projectData'));
                
                // Hide assignee details if visible
                $('#assignee-detail-view').addClass('d-none');
                $('.assignee-bubble').removeClass('active');
            });
            
            container.append(bubble);
        });
    }
    
    /**
     * Show assignee details
     */
    function showAssigneeDetails(assignee) {
        if (!assignee) {
            console.error('No assignee data provided to showAssigneeDetails');
            return;
        }
        
        console.log('Showing details for assignee:', assignee);
        
        // Set assignee name
        $('#assignee-detail-name').html(`<i class="fas fa-user"></i> ${assignee.name || 'Unknown'}`);
        
        // Show assignee detail view
        $('#assignee-detail-view').removeClass('d-none');
        $('#selected-assignee-info').removeClass('d-none');
        
        // Before creating charts, ensure containers are visible and sized
        $('#assignee-completion-chart, #assignee-category-chart').css({
            'min-height': '250px',
            'width': '100%',
            'display': 'block',
            'visibility': 'visible'
        });
        
        // Small delay to ensure DOM is updated before chart creation
        setTimeout(() => {
            // Create completion chart
            createAssigneeCompletionChart(assignee);
            
            // Create category breakdown chart
            createAssigneeCategoryChart(assignee);
            
            // Render blockers list
            renderAssigneeBlockersList(assignee);
        }, 50);
    }
    
    /**
     * Show project details
     */
    function showProjectDetails(project) {
        if (!project) {
            console.error('No project data provided to showProjectDetails');
            return;
        }
        
        console.log('Showing details for project:', project);
        
        // Set project name
        $('#project-detail-name').html(`<i class="fas fa-project-diagram"></i> ${project.name || 'Unknown'}`);
        
        // Show project detail view
        $('#project-detail-view').removeClass('d-none');
        $('#selected-project-info').removeClass('d-none');
        
        // Before creating charts, ensure containers are visible and sized
        $('#project-completion-chart, #project-resource-allocation-chart').css({
            'min-height': '250px',
            'width': '100%',
            'display': 'block',
            'visibility': 'visible'
        });
        
        // Small delay to ensure DOM is updated before chart creation
        setTimeout(() => {
            // Create completion chart
            createProjectCompletionChart(project);
            
            // Create resource allocation chart
            createProjectResourceAllocationChart(project);
            
            // Render team members
            renderProjectTeamMembers(project);
        }, 50);
    }
    
    /**
     * Create assignee completion chart
     */
    function createAssigneeCompletionChart(assignee) {
        // First ensure the container exists and has size
        const container = $('#assignee-completion-chart');
        if (container.length === 0) {
            console.error('Assignee completion chart container not found!');
            return;
        }
        
        // Make sure Plotly is available
        if (!ensurePlotly()) return;
        
        // Ensure the container has proper dimensions
        if (container.width() === 0 || container.height() === 0) {
            container.css({
                'min-height': '250px',
                'width': '100%',
                'display': 'block'
            });
        }
        
        // Calculate proper values
        const completed = assignee.completed_points || 0;
        const total = assignee.total_points || 0;
        const remaining = total > completed ? total - completed : 0;
        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
        
        const data = [{
            values: [completed, remaining],
            labels: ['Completed', 'Remaining'],
            type: 'pie',
            hole: 0.7,
            marker: {
                colors: ['#10b981', '#e2e8f0']
            },
            textinfo: 'percent',
            hoverinfo: 'label+value'
        }];
        
        const layout = {
            title: 'Completion Rate',
            height: 300,
            margin: {
                l: 0,
                r: 0,
                b: 30,
                t: 30,
                pad: 0
            },
            annotations: [{
                text: `${percentage}%`,
                font: {
                    size: 24,
                    color: '#334155'
                },
                showarrow: false,
                x: 0.5,
                y: 0.5
            }]
        };
        
        try {
            Plotly.newPlot('assignee-completion-chart', data, layout, {responsive: true});
            console.log('Assignee completion chart created successfully');
        } catch (error) {
            console.error('Error rendering assignee completion chart:', error);
            container.html('<div class="alert alert-danger">Failed to render chart. See console for details.</div>');
        }
    }
    
    /**
     * Create assignee category chart
     */
    function createAssigneeCategoryChart(assignee) {
        // First ensure the container exists and has size
        const container = $('#assignee-category-chart');
        if (container.length === 0) {
            console.error('Assignee category chart container not found!');
            return;
        }
        
        // Make sure Plotly is available
        if (!ensurePlotly()) return;
        
        // Ensure the container has proper dimensions
        if (container.width() === 0 || container.height() === 0) {
            container.css({
                'min-height': '250px',
                'width': '100%',
                'display': 'block'
            });
        }
        
        // Transform category breakdown to arrays for the chart
        const categoryBreakdown = assignee.category_breakdown || {};
        if (Object.keys(categoryBreakdown).length === 0) {
            container.html('<div class="alert alert-info">No category data available for this assignee.</div>');
            return;
        }
        
        const categories = Object.keys(categoryBreakdown);
        const values = categories.map(cat => categoryBreakdown[cat]);
        
        const categoryColors = {
            'Billable': '#3b82f6',
            'Product': '#8b5cf6',
            'Internal': '#f59e0b',
            'Other': '#94a3b8'
        };
        
        const colors = categories.map(cat => categoryColors[cat] || '#94a3b8');
        
        const data = [{
            x: categories,
            y: values,
            type: 'bar',
            marker: {
                color: colors
            },
            text: values.map(v => v.toFixed(1) + ' hrs'),
            textposition: 'auto'
        }];
        
        const layout = {
            title: 'Work Category Distribution',
            height: 300,
            margin: {
                l: 50,
                r: 20,
                b: 60,
                t: 30
            },
            yaxis: {
                title: 'Hours'
            },
            barmode: 'group'
        };
        
        try {
            Plotly.newPlot('assignee-category-chart', data, layout, {responsive: true});
            console.log('Assignee category chart created successfully');
        } catch (error) {
            console.error('Error rendering assignee category chart:', error);
            container.html('<div class="alert alert-danger">Failed to render chart. See console for details.</div>');
        }
    }
    
    /**
     * Render assignee blockers list
     */
    function renderAssigneeBlockersList(assignee) {
        const container = $('#assignee-blockers-list');
        container.empty();
        
        if (!assignee.blockers || assignee.blockers.length === 0) {
            container.append('<p class="text-muted">No blockers found</p>');
            return;
        }
        
        const table = $(`
            <table class="table table-sm">
                <thead>
                    <tr>
                        <th>Issue</th>
                        <th>Summary</th>
                        <th>Status</th>
                        <th>Due Date</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        `);
        
        const tbody = table.find('tbody');
        
        // Track counts of different blocker types
        let overdueCount = 0;
        let incompleteCount = 0;
        
        assignee.blockers.forEach(blocker => {
            // Extract blocker type or default to 'incomplete'
            const blockerType = blocker['blocker_type'] || blocker['blockerType'] || 'incomplete';
            
            // Create row with appropriate styling
            const rowClass = blockerType === 'overdue' ? 'table-danger' : 'table-warning';
            const row = $(`<tr class="${rowClass}"></tr>`);
            
            // Count by type
            if (blockerType === 'overdue') {
                overdueCount++;
            } else {
                incompleteCount++;
            }
            
            // Format due date
            let dueDate = 'Not set';
            const dueDateValue = blocker['Due date'] || blocker['due_date'] || blocker['dueDate'];
            if (dueDateValue) {
                try {
                    // Handle ISO string or date object
                    dueDate = new Date(dueDateValue).toLocaleDateString();
                } catch(e) {
                    console.warn('Could not format date:', dueDateValue, e);
                    dueDate = String(dueDateValue);
                }
            }
            
            // Add status class
            const statusClass = getStatusClass(blocker.Status);
            
            row.append(`<td>${blocker['Issue key']}</td>`);
            row.append(`<td>${blocker.Summary}</td>`);
            row.append(`<td><span class="status-pill ${statusClass}">${blocker.Status}</span></td>`);
            row.append(`<td>${dueDate}</td>`);
            
            tbody.append(row);
        });
        
        container.append(table);
        
        // Add a summary if there are multiple items
        if (assignee.blockers.length > 1) {
            const summaryHTML = $(`
                <div class="blockers-summary mb-2">
                    <small>
                        <span class="badge bg-danger">${overdueCount}</span> overdue/high priority &bull; 
                        <span class="badge bg-warning text-dark">${incompleteCount}</span> incomplete
                    </small>
                </div>
            `);
            container.prepend(summaryHTML);
        }
    }
    
    /**
     * Create project completion chart
     */
    function createProjectCompletionChart(project) {
        // First ensure the container exists and has size
        const container = $('#project-completion-chart');
        if (container.length === 0) {
            console.error('Project completion chart container not found!');
            return;
        }
        
        // Make sure Plotly is available
        if (!ensurePlotly()) return;
        
        // Ensure the container has proper dimensions
        if (container.width() === 0 || container.height() === 0) {
            container.css({
                'min-height': '250px',
                'width': '100%',
                'display': 'block'
            });
        }
        
        // Calculate proper values
        const completed = project.completed_points || 0;
        const total = project.total_points || 0;
        const remaining = total > completed ? total - completed : 0;
        const percentage = project.completion_percentage !== undefined ? 
            project.completion_percentage : (total > 0 ? Math.round((completed / total) * 100) : 0);
            
        const data = [{
            values: [completed, remaining],
            labels: ['Completed', 'Remaining'],
            type: 'pie',
            hole: 0.7,
            marker: {
                colors: ['#10b981', '#e2e8f0']
            },
            textinfo: 'percent',
            hoverinfo: 'label+value'
        }];
        
        const layout = {
            title: 'Project Completion',
            height: 300,
            margin: {
                l: 0,
                r: 0,
                b: 30,
                t: 30,
                pad: 0
            },
            annotations: [{
                text: `${percentage}%`,
                font: {
                    size: 24,
                    color: '#334155'
                },
                showarrow: false,
                x: 0.5,
                y: 0.5
            }]
        };
        
        try {
            Plotly.newPlot('project-completion-chart', data, layout, {responsive: true});
            console.log('Project completion chart created successfully');
        } catch (error) {
            console.error('Error rendering project completion chart:', error);
            container.html('<div class="alert alert-danger">Failed to render chart. See console for details.</div>');
        }
    }
    
    /**
     * Create project resource allocation chart
     */
    function createProjectResourceAllocationChart(project) {
        // First ensure the container exists and has size
        const container = $('#project-resource-allocation-chart');
        if (container.length === 0) {
            console.error('Project resource allocation chart container not found!');
            return;
        }
        
        // Make sure Plotly is available
        if (!ensurePlotly()) return;
        
        // Ensure the container has proper dimensions
        if (container.width() === 0 || container.height() === 0) {
            container.css({
                'min-height': '250px',
                'width': '100%',
                'display': 'block'
            });
        }
        
        // Transform assignee distribution to arrays for the chart
        const assigneeDistribution = project.assignee_distribution || {};
        if (Object.keys(assigneeDistribution).length === 0) {
            container.html('<div class="alert alert-info">No resource allocation data available for this project.</div>');
            return;
        }
        
        const assignees = Object.keys(assigneeDistribution);
        const hours = assignees.map(assignee => assigneeDistribution[assignee]);
        
        // Generate colors for each assignee
        const colors = generateColorsArray(assignees.length);
        
        const data = [{
            x: assignees,
            y: hours,
            type: 'bar',
            marker: {
                color: colors
            },
            text: hours.map(h => h.toFixed(1) + ' hrs'),
            textposition: 'auto'
        }];
        
        const layout = {
            title: 'Resource Allocation',
            height: 300,
            margin: {
                l: 50,
                r: 20,
                b: 80,
                t: 30
            },
            yaxis: {
                title: 'Hours'
            },
            xaxis: {
                tickangle: -45
            }
        };
        
        try {
            Plotly.newPlot('project-resource-allocation-chart', data, layout, {responsive: true});
            console.log('Project resource allocation chart created successfully');
        } catch (error) {
            console.error('Error rendering project resource allocation chart:', error);
            container.html('<div class="alert alert-danger">Failed to render chart. See console for details.</div>');
        }
    }
    
    /**
     * Render project team members
     */
    function renderProjectTeamMembers(project) {
        const container = $('#project-team-members');
        container.empty();
        
        if (!project.team_members || project.team_members.length === 0) {
            container.append('<p class="text-muted">No team members assigned</p>');
            return;
        }
        
        project.team_members.forEach(member => {
            if (!member || member === 'undefined' || member === 'null') return;
            
            // Create initials for the avatar
            const initials = getInitials(member);
            
            const teamMember = $(`
                <div class="team-member">
                    <div class="avatar">${initials}</div>
                    <span>${member}</span>
                </div>
            `);
            
            container.append(teamMember);
        });
    }
    
    /**
     * Clear assignee filter
     */
    $('#clear-assignee-filter').click(function() {
        // Remove active class from all assignee bubbles
        $('.assignee-bubble').removeClass('active');
        
        // Hide assignee details
        $('#assignee-detail-view').addClass('d-none');
        $('#selected-assignee-info').addClass('d-none');
    });
    
    /**
     * Clear project filter
     */
    $('#clear-project-filter').click(function() {
        // Remove active class from all project bubbles
        $('.project-bubble').removeClass('active');
        
        // Hide project details
        $('#project-detail-view').addClass('d-none');
        $('#selected-project-info').addClass('d-none');
    });
    
    /**
     * Helper function to get workload class based on total points
     */
    function getWorkloadClass(totalPoints) {
        if (totalPoints <= 20) {
            return 'workload-low';
        } else if (totalPoints <= 40) {
            return 'workload-medium';
        } else {
            return 'workload-high';
        }
    }
    
    /**
     * Helper function to get completion class based on completion percentage
     */
    function getCompletionClass(completionPercentage) {
        if (completionPercentage >= 80) {
            return 'completion-high';
        } else if (completionPercentage >= 50) {
            return 'completion-medium';
        } else {
            return 'completion-low';
        }
    }
    
    /**
     * Helper function to get status class based on status
     */
    function getStatusClass(status) {
        if (!status) return 'status-todo';
        
        status = status.toLowerCase();
        if (status.includes('done')) {
            return 'status-done';
        } else if (status.includes('progress') || status.includes('doing')) {
            return 'status-progress';
        } else if (status.includes('review')) {
            return 'status-review';
        } else if (status.includes('block')) {
            return 'status-blocked';
        } else {
            return 'status-todo';
        }
    }
    
    /**
     * Helper function to generate initials from a name
     */
    function getInitials(name) {
        if (!name) return '?';
        
        const parts = name.split(' ');
        if (parts.length === 1) {
            return parts[0].charAt(0).toUpperCase();
        } else {
            return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase();
        }
    }
    
    /**
     * Helper function to generate an array of colors
     */
    function generateColorsArray(count) {
        const baseColors = [
            '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', 
            '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'
        ];
        
        // If we need more colors than the base array, repeat them
        const colors = [];
        for (let i = 0; i < count; i++) {
            colors.push(baseColors[i % baseColors.length]);
        }
        
        return colors;
    }
    
    /**
     * Ensure that Plotly is available before attempting to render charts
     * @returns {boolean} - True if Plotly is available, false otherwise
     */
    function ensurePlotly() {
        if (typeof Plotly === 'undefined') {
            console.error('Plotly.js is not loaded! Charts will not render correctly.');
            
            // Add a message to the chart containers
            ['completion-chart', 'velocity-chart', 'billable-chart', 'capacity-chart'].forEach(id => {
                const container = $(`#${id}`);
                if (container.length > 0) {
                    container.html('<div class="alert alert-danger">Unable to load charts. Plotly.js library is missing.</div>');
                }
            });
            
            return false;
        }
        
        return true;
    }
    
    /**
     * Handle archive current sprint button click
     */
    $('#archive-current').click(function() {
        if (!currentDashboardData) {
            alert('Please generate a dashboard first.');
            return;
        }
        
        $.ajax({
            url: '/archive-sprint',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ sprint_index: currentSprintIndex }),
            success: function(response) {
